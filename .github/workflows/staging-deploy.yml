name: Deploy Brezel.ai API to Staging

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]
    types: [closed]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  DOCKER_COMPOSE_FILE: docker-compose.staging.yaml
  CONTAINER_NAME: google-maps-scraper-brezel-api-1

jobs:
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.24'
          cache: true

      - name: Download dependencies
        run: |
          go mod download
          go mod verify

      - name: Run tests
        run: |
          go test -v -race ./...

      - name: Build application
        run: |
          go build -o brezel-api .

  build-and-push:
    name: Build and Push Docker Image
    needs: [test]
    runs-on: ubuntu-latest
    if: |
      (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop') && 
      (github.event_name == 'push' || (github.event_name == 'pull_request' && github.event.pull_request.merged == true))
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Fix Go version in Dockerfile
        run: |
          # No changes needed - Dockerfile already uses Go 1.24
          echo "Dockerfile Go version:"
          grep "FROM golang" Dockerfile
          echo "go.mod version:"
          grep "^go " go.mod

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix=${{ github.ref_name }}-
            type=raw,value=staging,enable=${{ github.ref == 'refs/heads/develop' }}
            type=raw,value=latest,enable=${{ github.ref == 'refs/heads/main' }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64
          build-args: |
            BUILD_DATE=${{ github.event.head_commit.timestamp }}
            GIT_COMMIT=${{ github.sha }}
            VERSION=${{ github.ref_name }}

  deploy-staging:
    name: Deploy to Staging Environment
    needs: [build-and-push]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/develop'
    environment:
      name: staging
      url: http://64.226.112.104:8080
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Deploy to staging server
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.STAGING_HOST }}
          username: ${{ secrets.STAGING_USER }}
          key: ${{ secrets.STAGING_SSH_KEY }}
          timeout: 60m
          command_timeout: 60m
          script: |
            set -e
            
            # Colors for output
            RED='\033[0;31m'
            GREEN='\033[0;32m'
            YELLOW='\033[1;33m'
            BLUE='\033[0;34m'
            NC='\033[0m'
            
            print_status() { echo -e "${GREEN}[INFO]${NC} $1"; }
            print_warning() { echo -e "${YELLOW}[WARNING]${NC} $1"; }
            print_error() { echo -e "${RED}[ERROR]${NC} $1"; }
            print_header() { echo -e "${BLUE}[DEPLOY]${NC} $1"; }
            
            print_header "Smart Deployment for Multi-Core Compatibility"
            
            # Navigate to backend directory
            cd /home/${{ secrets.STAGING_USER }}/google-maps-scraper || {
              print_error "Backend directory not found"
              exit 1
            }
            
            # 1. Detect CPU configuration
            CPU_CORES=$(nproc 2>/dev/null || echo "1")
            OPTIMAL_CONCURRENCY=$((CPU_CORES / 2))
            if [ $OPTIMAL_CONCURRENCY -lt 1 ]; then
                OPTIMAL_CONCURRENCY=1
            fi
            
            print_status "System Analysis:"
            echo "   CPU Cores: $CPU_CORES"
            echo "   Optimal Concurrency: $OPTIMAL_CONCURRENCY"
            echo
            
            # Pull latest code
            print_status "Pulling latest backend code from develop branch..."
            git fetch origin
            git checkout develop
            git pull origin develop
            
            # Check for frontend (optional)
            FRONTEND_DIR="../scraper-webapp"
            if [ ! -d "$FRONTEND_DIR" ]; then
                FRONTEND_DIR="../google-maps-scraper-webapp"
            fi
            
            if [ -d "$FRONTEND_DIR" ]; then
                print_status "Found frontend at: $FRONTEND_DIR"
                cd "$FRONTEND_DIR"
                git fetch origin
                git checkout develop || git checkout main
                git pull
                cd /home/${{ secrets.STAGING_USER }}/google-maps-scraper
            else
                print_warning "Frontend directory not found, proceeding with backend only"
            fi
            
            # 2. Check and fix .env.staging (not .env)
            print_status "Configuring environment..."
            if [ ! -f ".env.staging" ]; then
                print_warning ".env.staging not found. Creating from example..."
                if [ -f ".env.staging.example" ]; then
                    cp .env.staging.example .env.staging
                elif [ -f ".env.example" ]; then
                    cp .env.example .env.staging
                elif [ -f ".env" ]; then
                    cp .env .env.staging
                else
                    print_error "No environment template found"
                    exit 1
                fi
            fi
            
            # Fix DSN for Linux if needed
            if grep -q "host\.docker\.internal" .env.staging; then
                print_status "Fixing DSN for Linux compatibility..."
                sed -i 's/host\.docker\.internal/172.17.0.1/g' .env.staging
            fi
            
            # Update passwords from GitHub secrets
            if [ ! -z "${{ secrets.STAGING_POSTGRES_PASSWORD }}" ]; then
                print_status "Updating database password..."
                sed -i "s/^POSTGRES_PASSWORD=.*/POSTGRES_PASSWORD=${{ secrets.STAGING_POSTGRES_PASSWORD }}/" .env.staging
                sed -i "s/scraper:strongpassword/scraper:${{ secrets.STAGING_POSTGRES_PASSWORD }}/" .env.staging
            fi
            
            if [ ! -z "${{ secrets.STAGING_CLERK_API_KEY }}" ]; then
                print_status "Updating Clerk API key..."
                sed -i "s/^CLERK_API_KEY=.*/CLERK_API_KEY=${{ secrets.STAGING_CLERK_API_KEY }}/" .env.staging
            fi
            
            # Add or update CONCURRENCY setting if on single core
            if [ $CPU_CORES -eq 1 ]; then
                print_status "Single-core server detected - setting explicit concurrency"
                if grep -q "^CONCURRENCY=" .env.staging; then
                    sed -i "s/^CONCURRENCY=.*/CONCURRENCY=1/" .env.staging
                elif grep -q "^# CONCURRENCY=" .env.staging; then
                    sed -i "s/^# CONCURRENCY=.*/CONCURRENCY=1/" .env.staging
                else
                    echo "" >> .env.staging
                    echo "# Single-core server configuration" >> .env.staging
                    echo "CONCURRENCY=1" >> .env.staging
                fi
            else
                print_status "Multi-core server detected - using auto-detection"
                sed -i '/^CONCURRENCY=/d' .env.staging
            fi
            
            print_status "Current configuration:"
            echo "   Database: $(grep "^DSN=" .env.staging | cut -d'@' -f2 | cut -d':' -f1 || echo 'not configured')"
            if grep -q "^CONCURRENCY=" .env.staging; then
                echo "   Concurrency: $(grep "^CONCURRENCY=" .env.staging | cut -d'=' -f2) (explicit)"
            else
                echo "   Concurrency: Auto-detected ($OPTIMAL_CONCURRENCY)"
            fi
            echo
            
            # 3. Build with no cache to ensure latest fixes (like your deploy.sh)
            print_status "Building Docker image with CPU optimizations..."
            print_status "This may take 10-20 minutes due to Playwright dependencies..."
            
            # Kill any existing build processes to avoid conflicts
            pkill -f "docker build" || true
            sleep 2
            
            # Build exactly like deploy.sh does
            docker build --no-cache -t brezel-staging-test . || {
                print_error "Docker build failed"
                print_status "Checking Docker status..."
                docker version
                docker info | grep -E "(Storage|Driver)"
                df -h /var/lib/docker
                exit 1
            }
            
            # Build frontend if exists
            if [ -d "$FRONTEND_DIR" ]; then
                print_status "Building frontend Docker image..."
                if [ ! -f "$FRONTEND_DIR/.env.staging" ]; then
                    if [ -f "$FRONTEND_DIR/.env.example" ]; then
                        cp "$FRONTEND_DIR/.env.example" "$FRONTEND_DIR/.env.staging"
                    fi
                    echo "NEXT_PUBLIC_API_URL=http://localhost:8080" >> "$FRONTEND_DIR/.env.staging"
                fi
                docker build --no-cache -t gmaps-webapp-staging "$FRONTEND_DIR" || print_warning "Frontend build failed, continuing..."
            fi
            
            # 4. Stop existing containers
            print_status "Stopping existing containers..."
            docker compose -f docker-compose.staging.yaml down --remove-orphans 2>/dev/null || true
            
            # Clean up to save space
            print_status "Cleaning up old images..."
            docker image prune -f || true
            
            # 5. Start application with .env.staging (important!)
            print_status "Starting application..."
            docker compose -f docker-compose.staging.yaml --env-file .env.staging up -d
            
            # 6. Wait and monitor
            print_status "Waiting for application startup..."
            sleep 5
            
            # 7. Test startup with detailed monitoring
            print_status "Monitoring startup process..."
            for i in {1..30}; do
                if curl -s -f http://localhost:8080/health >/dev/null 2>&1; then
                    print_status "Application is healthy!"
                    break
                else
                    if [ $i -eq 30 ]; then
                        print_error "Application failed to start"
                        echo
                        print_error "Debugging information:"
                        echo "Container status:"
                        docker ps -a | grep brezel
                        echo
                        echo "Recent logs:"
                        docker logs google-maps-scraper-brezel-api-1 --tail 10
                        echo
                        print_error "Troubleshooting suggestions:"
                        echo "   1. Check database connectivity: pg_isready -h 172.17.0.1 -p 5432"
                        echo "   2. Verify .env.staging configuration"
                        echo "   3. Check container logs: docker logs google-maps-scraper-brezel-api-1"
                        exit 1
                    fi
                    echo "   Startup attempt $i/30..."
                    sleep 2
                fi
            done
            
            # 8. Show success information
            print_header "Deployment Successful!"
            echo
            
            # Get server info
            SERVER_IP=$(hostname -I | awk '{print $1}' 2>/dev/null || echo "localhost")
            CONTAINER_CPU_INFO=$(docker exec google-maps-scraper-brezel-api-1 nproc 2>/dev/null || echo "unknown")
            
            print_status "Server Information:"
            echo "   Server IP: $SERVER_IP"
            echo "   Host CPUs: $CPU_CORES"
            echo "   Container CPUs: $CONTAINER_CPU_INFO"
            echo
            
            print_status "Application URLs:"
            echo "   Web Interface:  http://$SERVER_IP:8080/"
            echo "   Health Check:   http://$SERVER_IP:8080/health"
            echo "   API Status:     http://$SERVER_IP:8080/api/v1/status"
            echo "   API Docs:       http://$SERVER_IP:8080/api/docs"
            echo
            
            print_status "Application Status:"
            curl -s http://localhost:8080/api/v1/status | jq . 2>/dev/null || curl -s http://localhost:8080/api/v1/status
            echo
            
            print_status "Management Commands:"
            echo "   View logs:      docker logs google-maps-scraper-brezel-api-1"
            echo "   Restart:        docker compose -f docker-compose.staging.yaml restart"
            echo "   Stop:           docker compose -f docker-compose.staging.yaml down"
            echo "   Monitor:        docker stats google-maps-scraper-brezel-api-1"
            echo
            
            print_header "Your application is ready and optimized for $CPU_CORES CPU core(s)!"

      - name: Run smoke tests
        if: success()
        run: |
          sleep 5
          echo "Running basic API tests..."
          
          # Test health endpoint
          echo "Testing health endpoint..."
          curl -f -s http://64.226.112.104:8080/health || {
            echo "Health check failed"
            exit 1
          }
          
          echo "All tests passed successfully"

      - name: Notify deployment status
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const status = '${{ job.status }}';
            const message = status === 'success' 
              ? 'Successfully deployed to staging environment' 
              : 'Deployment to staging failed';
            
            github.rest.repos.createCommitStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              sha: context.sha,
              state: status === 'success' ? 'success' : 'failure',
              description: message,
              context: 'Staging Deployment'
            });