name: Deploy Brezel.ai API to Staging

on:
  push:
    branches: [main, develop, feature/fix-staging-pipeline]  # Added your feature branch
  pull_request:
    branches: [main, develop]
    types: [closed]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  FRONTEND_IMAGE_NAME: brezel-ai/scraper-webapp
  DOCKER_COMPOSE_FILE: docker-compose.staging.yaml
  CONTAINER_NAME: google-maps-scraper-brezel-api-1

jobs:
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.24'
          cache: true

      - name: Download dependencies
        run: |
          go mod download
          go mod verify

      - name: Run tests
        run: |
          go test -v -race ./...

      - name: Build application
        run: |
          go build -o brezel-api .

  build-and-push-backend:
    name: Build and Push Backend Docker Image
    needs: [test]
    runs-on: ubuntu-latest
    if: |
      (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop' || github.ref == 'refs/heads/feature/fix-staging-pipeline') && 
      (github.event_name == 'push' || (github.event_name == 'pull_request' && github.event.pull_request.merged == true))
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix=${{ github.ref_name }}-
            type=raw,value=staging,enable=${{ github.ref == 'refs/heads/develop' || github.ref == 'refs/heads/feature/fix-staging-pipeline' }}
            type=raw,value=latest,enable=${{ github.ref == 'refs/heads/main' }}

      - name: Build and push Backend Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: |
            type=gha
            type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:buildcache
          cache-to: |
            type=gha,mode=max
            type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:buildcache,mode=max
          platforms: linux/amd64
          build-args: |
            BUILD_DATE=${{ github.event.head_commit.timestamp }}
            GIT_COMMIT=${{ github.sha }}
            VERSION=${{ github.ref_name }}

  build-and-push-frontend:
    name: Build and Push Frontend Docker Image
    needs: [test]
    runs-on: ubuntu-latest
    if: |
      (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop' || github.ref == 'refs/heads/feature/fix-staging-pipeline') && 
      (github.event_name == 'push' || (github.event_name == 'pull_request' && github.event.pull_request.merged == true))
    steps:
      - name: Checkout backend code
        uses: actions/checkout@v4
        with:
          path: backend

      - name: Checkout frontend repository
        id: check-frontend
        run: |
          # Clone the correct frontend repository
          if git clone https://github.com/brezel-ai/scraper-webapp.git frontend 2>/dev/null; then
            echo "frontend_exists=true" >> $GITHUB_OUTPUT
            echo "âœ… Frontend repository (brezel-ai/scraper-webapp) found"
            cd frontend
            echo "ğŸ“‹ Frontend repository info:"
            echo "Current branch: $(git branch --show-current)"
            echo "Latest commit: $(git log --oneline -1)"
          else
            echo "frontend_exists=false" >> $GITHUB_OUTPUT
            echo "âš ï¸ Frontend repository not found, skipping frontend build"
          fi

      - name: Set up Docker Buildx
        if: steps.check-frontend.outputs.frontend_exists == 'true'
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        if: steps.check-frontend.outputs.frontend_exists == 'true'
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Create frontend environment file
        if: steps.check-frontend.outputs.frontend_exists == 'true'
        run: |
          cd frontend
          
          # Create staging environment file
          cat > .env.staging << EOF
          NEXT_PUBLIC_API_URL=http://64.226.112.104:8080
          NEXT_PUBLIC_ENVIRONMENT=staging
          NODE_ENV=production
          EOF
          
          echo "âœ… Created frontend environment configuration"
          echo "Frontend environment variables:"
          cat .env.staging

      - name: Build and push Frontend Docker image
        if: steps.check-frontend.outputs.frontend_exists == 'true'
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ env.FRONTEND_IMAGE_NAME }}:staging
            ${{ env.REGISTRY }}/${{ env.FRONTEND_IMAGE_NAME }}:${{ github.sha }}
            ${{ env.REGISTRY }}/${{ env.FRONTEND_IMAGE_NAME }}:feature-${{ github.ref_name }}
          cache-from: |
            type=gha
            type=registry,ref=${{ env.REGISTRY }}/${{ env.FRONTEND_IMAGE_NAME }}:buildcache
          cache-to: |
            type=gha,mode=max
            type=registry,ref=${{ env.REGISTRY }}/${{ env.FRONTEND_IMAGE_NAME }}:buildcache,mode=max
          platforms: linux/amd64
          build-args: |
            BUILD_DATE=${{ github.event.head_commit.timestamp }}
            GIT_COMMIT=${{ github.sha }}
            VERSION=${{ github.ref_name }}

  deploy-staging:
    name: Deploy to Staging Environment
    needs: [build-and-push-backend, build-and-push-frontend]
    if: |
      always() && 
      needs.build-and-push-backend.result == 'success' && 
      (github.ref == 'refs/heads/develop' || github.ref == 'refs/heads/feature/fix-staging-pipeline')
    runs-on: ubuntu-latest
    environment:
      name: staging
      url: http://64.226.112.104:8080
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Deploy to staging server
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.STAGING_HOST }}
          username: ${{ secrets.STAGING_USER }}
          key: ${{ secrets.STAGING_SSH_KEY }}
          timeout: 15m
          command_timeout: 15m
          script: |
            set -e
            
            echo "ğŸš€ Starting deployment to staging server"
            echo "Time: $(date)"
            echo "User: $(whoami)"
            
            # Navigate to backend directory
            cd /home/${{ secrets.STAGING_USER }}/google-maps-scraper || {
              echo "ERROR: Backend directory not found"
              exit 1
            }
            
            # Pull latest configuration from feature branch
            echo "ğŸ“¥ Pulling latest configuration..."
            git fetch origin
            git checkout feature/fix-staging-pipeline || git checkout develop
            git pull origin feature/fix-staging-pipeline || git pull origin develop
            
            # Setup environment
            echo "âš™ï¸ Configuring environment variables..."
            if [ ! -f ".env" ]; then
              echo "No .env file found, creating from template..."
              cp .env.example .env
            fi
            
            # Backup current configuration
            cp .env .env.backup
            
            # Fix Docker networking for Linux
            sed -i 's/host\.docker\.internal/172.17.0.1/g' .env
            
            # Update secrets from GitHub
            if [ ! -z "${{ secrets.STAGING_POSTGRES_PASSWORD }}" ]; then
              echo "Updating database password..."
              sed -i "s/^POSTGRES_PASSWORD=.*/POSTGRES_PASSWORD=${{ secrets.STAGING_POSTGRES_PASSWORD }}/" .env
              sed -i "s/scraper:strongpassword/scraper:${{ secrets.STAGING_POSTGRES_PASSWORD }}/" .env
            fi
            
            if [ ! -z "${{ secrets.STAGING_CLERK_API_KEY }}" ]; then
              echo "Updating Clerk API key..."
              sed -i "s/^CLERK_API_KEY=.*/CLERK_API_KEY=${{ secrets.STAGING_CLERK_API_KEY }}/" .env
            fi
            
            # Optimize for single-core server
            CPU_CORES=$(nproc)
            echo "Server has $CPU_CORES CPU cores"
            if [ $CPU_CORES -eq 1 ]; then
              echo "Configuring for single-core performance..."
              if grep -q "^CONCURRENCY=" .env; then
                sed -i "s/^CONCURRENCY=.*/CONCURRENCY=1/" .env
              else
                echo "CONCURRENCY=1" >> .env
              fi
            fi
            
            # Login to GitHub Container Registry
            echo "ğŸ” Logging in to GitHub Container Registry..."
            echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin
            
            # Stop existing containers
            echo "ğŸ›‘ Stopping current containers..."
            docker compose -f docker-compose.staging.yaml down --remove-orphans || true
            
            # Clean up to save space
            echo "ğŸ§¹ Cleaning up old images..."
            docker image prune -f || true
            
            # Pull pre-built backend image (CRITICAL: No local building)
            echo "ğŸ“¦ Pulling pre-built backend image..."
            docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:staging || {
              echo "âŒ ERROR: Failed to pull backend staging image"
              exit 1
            }
            
            # Pull pre-built frontend image
            echo "ğŸ“¦ Pulling pre-built frontend image..."
            FRONTEND_AVAILABLE=false
            if docker pull ${{ env.REGISTRY }}/${{ env.FRONTEND_IMAGE_NAME }}:staging 2>/dev/null; then
              echo "âœ… Frontend image (brezel-ai/scraper-webapp) pulled successfully"
              FRONTEND_AVAILABLE=true
            else
              echo "âš ï¸ Frontend image not available, deploying backend only"
              # Remove frontend from docker-compose temporarily
              cp docker-compose.staging.yaml docker-compose.staging.yaml.backup
              sed -i '/frontend:/,/^$/d' docker-compose.staging.yaml
            fi
            
            # Start containers with pre-built images
            echo "ğŸš€ Starting services with docker-compose..."
            docker compose -f docker-compose.staging.yaml --env-file .env up -d
            
            # Wait for startup (longer timeout for single-core server)
            echo "â³ Waiting for services to initialize..."
            sleep 30
            
            # Health check with more attempts for slower server
            echo "ğŸ¥ Checking backend health status..."
            HEALTH_CHECK_URL="http://localhost:8080/health"
            MAX_ATTEMPTS=60
            
            for i in $(seq 1 $MAX_ATTEMPTS); do
              if curl -s -f $HEALTH_CHECK_URL > /dev/null 2>&1; then
                echo "âœ… Backend is running and healthy!"
                echo ""
                echo "ğŸ‰ Deployment completed successfully"
                echo "ğŸ”— Backend API: http://64.226.112.104:8080"
                echo "ğŸ”— Health endpoint: http://64.226.112.104:8080/health"
                echo "ğŸ”— API documentation: http://64.226.112.104:8080/api/docs"
                
                if [ "$FRONTEND_AVAILABLE" = true ]; then
                  echo "ğŸ”— Frontend application: http://64.226.112.104:3000"
                else
                  echo "âš ï¸  Frontend: Not deployed (image not available)"
                fi
                
                echo ""
                echo "ğŸ“‹ Running containers:"
                docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
                echo ""
                echo "ğŸ’¾ System resources:"
                echo "Memory: $(free -h | awk '/^Mem:/ {print $3 "/" $2}')"
                echo "Disk: $(df -h / | awk 'NR==2 {print $3 "/" $2 " (" $5 " used)"}')"
                exit 0
              else
                echo "Health check attempt $i of $MAX_ATTEMPTS - Backend not ready yet"
                if [ $i -eq $MAX_ATTEMPTS ]; then
                  echo "âŒ ERROR: Backend failed to start after $MAX_ATTEMPTS attempts"
                  echo ""
                  echo "ğŸ” Container status:"
                  docker ps -a
                  echo ""
                  echo "ğŸ“‹ Container logs:"
                  docker compose -f docker-compose.staging.yaml logs --tail 50
                  exit 1
                fi
                sleep 5
              fi
            done

      - name: Run smoke tests
        if: success()
        run: |
          echo "ğŸ§ª Running smoke tests..."
          
          # Test health endpoint
          echo "Testing health endpoint..."
          curl -f -s http://64.226.112.104:8080/health || {
            echo "âŒ Health check failed"
            exit 1
          }
          
          echo "âœ… All tests passed successfully"

      - name: Notify deployment status
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const status = '${{ job.status }}';
            const message = status === 'success' 
              ? 'âœ… Successfully deployed to staging environment' 
              : 'âŒ Deployment to staging failed';
            
            github.rest.repos.createCommitStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              sha: context.sha,
              state: status === 'success' ? 'success' : 'failure',
              description: message,
              context: 'Staging Deployment'
            });
